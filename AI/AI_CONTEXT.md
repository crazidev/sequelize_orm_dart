# Sequelize Dart - AI Context & Architecture Guide

## Project Overview

Sequelize Dart is a dual-platform ORM that provides Sequelize.js integration for Dart with type-safe query building and code generation support.

## Core Architecture

### Dual Platform Strategy

The project uses **conditional exports** to maintain clean platform separation:

```dart
export 'model_stub.dart'
    if (dart.library.js_interop) 'model_js.dart'
    if (dart.library.io) 'model_dart.dart';
```

**Why this matters:**

- Prevents JS interop code from "sneaking" into Dart VM builds
- Eliminates runtime errors when JS-specific APIs are unavailable
- Maintains identical API surface across platforms
- Enables compile-time platform detection

### Platform Detection

- **`dart.library.js_interop`**: Activated when compiling to JavaScript (dart2js)
- **`dart.library.io`**: Activated when running on Dart VM (server)

## Key Components

### 1. Conditional Import Pattern

**File Structure:**

```
lib/src/
├── model/
│   ├── model.dart          # Conditional export (main entry)
│   ├── model_stub.dart     # Abstract base with UnimplementedError
│   ├── model_js.dart       # JS interop implementation
│   └── model_dart.dart     # Bridge client implementation
├── sequelize/
│   ├── sequelize.dart      # Conditional export
│   ├── sequelize_stub.dart
│   ├── sequelize_js.dart   # Direct Sequelize.js calls
│   └── sequelize_dart.dart # Bridge communication
└── query_engine/
    ├── query_engine.dart   # Conditional export
    ├── query_engine_stub.dart
    ├── query_engine_js.dart # Direct JS execution
    └── query_engine_dart.dart # Bridge JSON-RPC calls
```

**Pattern:**

1. **Stub file**: Abstract interface with `UnimplementedError`
2. **JS file**: Direct `dart:js_interop` usage with extension types
3. **Dart file**: Bridge client communication via JSON-RPC

### 2. Bridge Architecture (Dart Server)

**Communication Flow:**

```
Dart Code → BridgeClient → JSON-RPC → Node.js Process → Sequelize.js → Database
```

**Key Components:**

- **BridgeClient**: Singleton managing Node.js process lifecycle
- **JSON-RPC**: Structured communication over stdin/stdout
- **Process Management**: Automatic startup, monitoring, cleanup

**Bridge Features:**

- Connection pooling managed by Sequelize.js
- SQL logging with formatted output
- Error propagation with detailed context
- Automatic model registration and association setup

### 3. JS Interop Architecture (dart2js)

**Communication Flow:**

```
Dart Code → JS Interop → Sequelize.js → Database
```

**Key Components:**

- **Extension Types**: Type-safe JS object wrappers
- **Direct API Calls**: No bridge overhead
- **Native Performance**: Direct function calls

**JS Interop Features:**

- Extension types for Sequelize objects
- Symbol-based operator mapping
- Automatic JS/Dart value conversion
- Hoisted include options for nested sorting

## Query Builder System

### Type-Safe Query Building

**Generated Query Classes:**

```dart
// Auto-generated by build_runner
class $Users {
  TypedColumn<Users, dynamic> get id => TypedColumn('id');
  TypedColumn<Users, dynamic> get email => TypedColumn('email');

  QueryBuilder<Users> where(TypedColumn<Users, dynamic> column, Operator op, dynamic value);
  QueryBuilder<Users> and(List<QueryBuilder<Users>> conditions);
  QueryBuilder<Users> or(List<QueryBuilder<Users>> conditions);
}
```

**Operator System:**

- **Comparison**: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`
- **Logical**: `and`, `or`, `not`
- **String**: `like`, `iLike`, `startsWith`, `endsWith`
- **List**: `in_`, `notIn`, `any`, `all`
- **Regex**: `regexp`, `iRegexp`
- **Null**: `isNull`, `isNotNull`

**Query Execution:**

```dart
final users = await Users.instance.findAll(
  (q) => Query(
    where: and([
      q.id.gt(10),
      q.email.like('%@example.com'),
    ]),
    order: [['createdAt', 'DESC']],
    limit: 10,
  ),
);
```

## Code Generation System

### Model Annotations

**Core Annotations:**

```dart
@Table(tableName: 'users')
class Users {
  @ModelAttributes(
    name: 'id',
    type: DataType.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  )
  dynamic id;

  static $Users get instance => $Users();
}
```

**Generated Output:**

- Query builder classes with type safety
- Model implementation with platform-specific logic
- Association setup methods
- Attribute/option JSON converters

## Platform-Specific Implementation Details

### Dart Server (Bridge) Implementation

**Key Characteristics:**

- JSON-RPC communication over stdin/stdout
- Singleton Node.js process management
- Connection pooling via Sequelize.js
- Error handling with detailed context

**Bridge Client Features:**

- Automatic process startup and monitoring
- Request timeout handling
- SQL logging callback integration
- Graceful shutdown and cleanup

### JS Interop (dart2js) Implementation

**Key Characteristics:**

- Direct Sequelize.js API calls
- Extension types for type safety
- Symbol-based operator mapping
- Native performance

**JS Interop Features:**

- Extension types for Sequelize objects
- Automatic value conversion (Dart ↔ JS)
- Hoisted include options for complex queries
- SQL expression builders

## Development Patterns

### 1. Conditional Export Pattern

**Always use this pattern for platform-specific code:**

```dart
// main_export_file.dart
export 'stub_file.dart'
    if (dart.library.js_interop) 'js_implementation.dart'
    if (dart.library.io) 'dart_implementation.dart';
```

### 2. Interface-First Design

**Define interfaces in stub files:**

```dart
// stub_file.dart
abstract class SomeInterface {
  Future<void> someMethod();
  // Throw UnimplementedError in stub
}
```

### 3. Platform-Specific Implementation

**JS Implementation:**

```dart
// js_implementation.dart
import 'dart:js_interop';

class SomeInterfaceImpl extends SomeInterface {
  @override
  Future<void> someMethod() async {
    // Direct JS interop calls
  }
}
```

**Dart Implementation:**

```dart
// dart_implementation.dart
class SomeInterfaceImpl extends SomeInterface {
  @override
  Future<void> someMethod() async {
    // Bridge client calls
    await bridge.call('someMethod', {});
  }
}
```

## Error Handling Patterns

### Bridge Errors

- Detailed error messages from Node.js
- Stack traces and SQL context
- Automatic error propagation

### JS Interop Errors

- Direct JavaScript error handling
- Type conversion error handling
- Promise rejection handling

## Testing Strategy

### Integration Tests

- Operator functionality verification
- SQL output validation
- Cross-platform compatibility

### Platform Tests

- Bridge communication testing
- JS interop functionality
- Error handling verification

## Performance Considerations

### Bridge Overhead

- JSON serialization/deserialization
- Process communication latency
- Connection pooling benefits

### JS Interop Benefits

- Direct function calls
- No serialization overhead
- Native JavaScript performance

## Future Development Guidelines

### Adding New Features

1. Define interface in stub file
2. Implement JS version with direct interop
3. Implement Dart version with bridge calls
4. Add conditional export
5. Write tests for both platforms

### Maintaining Platform Separation

- Never import JS interop files from Dart VM code
- Use conditional exports consistently
- Test on both platforms regularly
- Document platform-specific behavior
